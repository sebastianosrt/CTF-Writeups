# Intigriti challenge 0825 - Catflix

## Overview
The challenge is a simple application made with NextJS that only allows to register and to log in.
Once logged in it is possible to watch some fantastic AI generated cat videos.
![](https://i.postimg.cc/pLRWj0Dg/0825.png)

## Code review 
After analyzing the source code, the only thing that felt not completely right is the following in `middleware.ts`:
```ts
export async function middleware(request: NextRequest) {
	const { pathname, searchParams } = request.nextUrl;
	const token = await getToken({ req: request, secret: process.env.NEXTAUTH_SECRET });

	if (!token && pathname === '/' && (
		searchParams.has('utm_source') ||
		searchParams.has('utm_medium') ||
		searchParams.has('utm_campaign')
	)) {
		const requestHeaders = new Headers(request.headers);
		const res = {
			headers: requestHeaders,
			request: {
				headers: requestHeaders,
			}
		};

		// TODO: Handle analytics

		return NextResponse.next(res);
	};
```

The middleware forwards the request headers to the next middleware or route using `NextResponse.next()`, if the user is not authenticated and an UTM parameter is specified. 

According to the [Next.js documentation](https://nextjs.org/docs/app/api-reference/functions/next-response#next), only the `request: { headers }` field is valid. The `headers: requestHeaders` field, as used above, is **not documented**.

Additionally an hint was given in the source code:
```
{/* Hint for CTF players */}
{/* Internal services use default configurations */}
```
This likely means that we have to exploit an internal service, so an SSRF would be very useful.

### Exploring NextJs internals

The following vulnerability was discoverable using BurpSuite's param-miner extension, but to understand what happens under the hood we have to explore the Nextjs internals.

Looking at the Next.js implementation of `NextResponse.next()` in `response.ts`, we see that the headers object passed to `next()` is applied as response headers for the next middleware in the chain. This means that request headers can be "smuggled" into response headers:

[source](https://github.com/vercel/next.js/blob/0fdaf93770d66d61b588bc8d06c5ec2ec0e66323/packages/next/src/server/web/spec-extension/response.ts#L146) `packages/next/src/server/web/spec-extension/response.ts`
```ts
static next(init?: MiddlewareResponseInit) {
	const headers = new Headers(init?.headers)
	headers.set('x-middleware-next', '1')

	handleMiddlewareField(init, headers)
	return new NextResponse(null, { ...init, headers })
}
```

So effectively, this application’s middleware lets us **inject arbitrary internal headers** into the response that is forwarded to each middleware/route.

#### Looking for exploitable internal headers

It is known that Nextjs uses special internal headers for routing and processing logic.
For example CVE-2025-29927 exploited `x-middleware-subrequest` or CVE-2023-46298 exploited `x-middleware-prefetch` (credits to [zhero](https://x.com/zhero___)).

Digging into the internal routing logic within `packages/next/src/server/lib/router-utils/resolve-routes.ts` [source](https://github.com/vercel/next.js/blob/0fdaf93770d66d61b588bc8d06c5ec2ec0e66323/packages/next/src/server/lib/router-utils/resolve-routes.ts#L603), we can observe how different internal headers can alter the application's behavior.

When a **Location** header is included in a middleware’s response, the route resolver interprets it as a redirect and marks the request as complete by setting `finished: true`.

```ts
if (middlewareHeaders['location']) {
	const value = middlewareHeaders['location'] as string

	// Only process Location header as a redirect if it has a proper redirect status
	// This prevents a Location header with non-redirect status from being treated as a redirect
	const isRedirectStatus = allowedStatusCodes.has(
		middlewareRes.status
	)

	if (isRedirectStatus) {
		// Process as redirect: update parsedUrl and convert to relative URL
		const rel = getRelativeURL(value, initUrl)
		resHeaders['location'] = rel
		parsedUrl = url.parse(rel, true)

		return {
			parsedUrl,
			resHeaders,
			finished: true,
			statusCode: middlewareRes.status,
		}
	}
```

Subsequently, when the router server in `packages/next/src/server/lib/router-server.ts` encounters this `finished` flag and the parsedUrl has a protocol (indicating an absolute URL), it proxies the request to the URL specified in the Location header.

```ts
if (finished && parsedUrl.protocol) {
	return await proxyRequest(
		req,
		res,
		parsedUrl,
		undefined,
		getRequestMeta(req, 'clonableBody')?.cloneBodyStream(),
		config.experimental.proxyTimeout
	)
}
```

Because the server proxies the entire request, including the method, headers, and body, and returns the full response, this vulnerability becomes a full-read **Server-Side Request Forgery (SSRF)**.

![](https://i.postimg.cc/Yqcqr2j2/0825-ssrf.png)

Note: I had already found this ssrf vulnerability before while solving _Under Nextruction_, a challenge by [mizu](https://x.com/kevin_mizu). You can find its writeup [here](https://mizu.re/post/fcsc-2025-writeups#under-nextruction).

## Finding the internal service

With the SSRF, we can now probe the internal network and enumerate the open ports for services running on localhost, by sending requests to `http://localhost:[port]`. This process quickly reveals a service running on port 8080, and the response headers identify it as a Jenkins server:

![](https://i.postimg.cc/2jLSNLkX/0825-jenkins.png)


In its dashboard's source I found the endpoint `/manage/`, that shows the following warning:
> Jenkins is currently unsecured and allows anyone on the network to launch processes on your behalf. It is recommended to set up security and to limit anonymous access even on private networks.

Since the **authentication** is **disabled**, achieving RCE on this service is trivial.

## Exploiting Jenkins

A default Jenkins installation includes a "Script Console" accessible to administrators. This feature is intended for troubleshooting and administration by allowing the execution of arbitrary Groovy scripts on the server.

![](https://i.postimg.cc/TwF2Wf99/0825-script.png)

This console provides a direct path to Remote Code Execution (RCE). Any valid Groovy code entered into the console will be executed by the Jenkins server, giving us full control over the underlying machine.

![](https://i.postimg.cc/6qZWrgbN/0825-rce.png)

To get the flag we can execute `cat /app/flag.txt` by sending a request containing the groovy script `"cat /app/flag.txt".execute().text` directly to `/manage/script`:

![](https://i.postimg.cc/wv7Tv7hM/0825rce.png)

#### Flag
`INTIGRITI{1337a0b4-56bf-4c2a-9fd2-b4a6d7237ce2}`